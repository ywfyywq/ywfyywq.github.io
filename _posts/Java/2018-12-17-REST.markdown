---
layout: post
title: REST实战
date: 2018-11-20
comments: true 
tags: 学习笔记
summary: 揭开WEB作为一个应用平台的神秘面纱，以及展示如何将WEB架构应用于常见的企业计算问题。帮助大家建造一个可以由其它系统使用的开放的信息平台，它避开集成，而支持组合，但仍然实现了有价值的业务行为。这是一个分布式的、超媒体驱动的应用平台。
---
### 将Web作为建造分布式系统的平台

* 从资源的角度思考

要使用一个资源，我们需要能够在网络上标识它，还需要有一些手段来操作它。标识资源的就被称作标识符。

Web上用来称呼标识符的术语：

| 术语 | 注释 |
| ------ | ------ |
| URI(Uniform Resource Identifier | 常被误认为Universal或者Unique |
| IRI(International Resource Identifier | URI的升级版，允许使用国际字符方案 |
| URN(Uniform Resource Name | 这是一个URI，使用"urn"作为方案，用来在一个特殊的"命名空间"中表达唯一的名字 |
| URL(Uniform Resource Locator | 这是一个URI，用来表示关于与所标识的资源交互的方式的信息。这个术语现在已经过时了，因为并非所有的URI都需要表达特定的交互协议的信息 |
| 地址 | 很多人认为资源在WEB上有地址，作为结果，说的其实就是资源的标识符 |

* 资源表述

Web是无处不在的，HTTP这个URI方案今天甚至成为了“标识”和“地址”的同义词。

资源必须至少有一个标识符，以便于在Web上寻址，每个标识符与一个或多个表述相关联。一个表述，指的是某个资源在某特定的时刻的状态的转化形式或者视图。这个视图被编码为一种或多种可转移的格式，例如XHTML、Atom、XML、JSON，甚至是纯文本、逗号分隔的值（CSV）、MP3或者JPEG。

* 表述格式和URI

有一个误解是，每一个不同的资源表述都需要有自己的URI。使用内容协商机制，消费者能够就特定的表述格式进行协商。他们通过将HTTP的Accept请求头信息与一系列他们喜欢处理的媒体类型组装在一起来做到这件事情。

* 通信的艺术

HTTP所支持的动词的集合——GET、POST、PUT、DELETE、OPTIONS、HEAD、TRACE、CONNECT以及PATCH——构成了一个足够通用的协议，可以支持广泛的解决方案。

除了动词外，HTTP也定义了一个响应代码的集合（例如200 OK，201 Created以及404Not Found），来协调由动词所引起的交互。

* 从Web架构到REST架构风格

使用有限的一组操作和统一的语义来建造一种到处存在的基础架构，能够支持任何类型的应用。这种架构风格被称为“表述性状态转移”（REpresentational State Transfer）。REST描述了Web作为一个分布式超媒体的应用，相互链接的资源通过交换资源状态的表述来进行通信。

* 超媒体

在一个超媒体系统中，应用状态通过唯一可标识的资源的表述来表达。应用能够执行的迁移状态的标识符是以链接的形式内嵌在当前状态的表述之中的。

简单来说，这就是著名的“将超媒体作为状态的引擎（hypermedia as the engine of application state，缩写为HATEOAS）

* Richardson的成熟度模型

![Richardson的成熟度模型][Richardson]

[Richardson]: /images/blog/REST/Richardson.png

零级服务：服务成熟度中最基本的一级，其特征为那些服务有单个的URI，并且使用单个的HTTP方法（通常是POST）。

一级服务：服务成熟度的下一级别使用了很多URI，但是只使用单个的HTTP动词。

二级服务：二级服务使用了大量的可通过URI寻址的资源。这样的服务支持多个HTTP动词来暴露资源。包含在这个级别的是CRUD服务。

三级服务：最Web感知的服务级别，支持超媒体作为应用状态的引擎的观念。即，表述包含了消费者可能感兴趣的到其他资源的URI链接。这种服务通过追踪资源来引导消费者，结果是引起应用状态的迁移。


### Restbucks：一家有着全球抱负的小咖啡店

![HTTP远程过程调用的架构][SimpleHTTPArchitecture]

[SimpleHTTPArchitecture]: /images/blog/REST/SimpleHTTPArchitecture.png

* URI模板

在分布式系统中，服务提供者经常会提供机器可以阅读的元数据，描述客户应该如何与服务进行绑定和交互，例如，一般会用到接口定义语言(IDL)，例如WS-*Web服务中的Web服务描述语言（WSDL），实现CORBA系统时则是使用CORBA-IDL。对于WEB来说，会使用各种各样的元数据技术来描述服务契约，包括URI模板，它描述一个服务所支持的那组URI的句法模式。

例如：http://restbucks.com/order/{order_id}

* URI隧道技术

URI隧道技术是将URI作为跨越系统边界转移信息的一种方式来使用，其做法是将信息编码到URI内部。

将方法调用映射到URI：

![将方法调用映射到URI][URIMapping]

[URIMapping]: /images/blog/REST/URIMapping.png

URI隧道技术的HTTP请求/响应:

![URI隧道技术的HTTP请求/响应][ResponseForURITunnel]

[ResponseForURITunnel]: /images/blog/REST/ResponseForURITunnel.png

从URI中提取业务对象：

{% highlight cs %}
public void ProcessPost(HttpListenerContext context)
{
	// Parse the URI
	Order order = ParseUriForOrderDetails(context.Request.QueryString);
	string response = string.Empty;
	if (order != null)
	{
		// Process the order by calling the mapped method
		var orderConfirmation = RestbucksService.PlaceOrder(order);
		response = "OrderId=" + orderConfirmation.OrderId.ToString();
	}
	else
	{
		response = ″Failure: Could not place order.″;
	}
	// Write to the response stream
	using (var sw = new StreamWriter(context.Response.OutputStream))
	{
		sw.Write(response);
	}
}
{% endhighlight %}


URI技术的客户端：

{% highlight cs %}
public OrderConfirmation PlaceOrder(Order order)
{
	// Create the URI
	var sb = new StringBuilder(″http://restbucks.com/PlaceOrder?″);
	sb.AppendFormat(″coffee={0}″, order.Coffee.ToString());
	sb.AppendFormat(″&size={0}″, order.Size.ToString());
	sb.AppendFormat(″&milk={0}″, order.Milk.ToString());
	sb.AppendFormat(″&location={0}″, order.ConsumeLocation.ToString());
	// Set up the POST request
	var request = HttpRequest.Create(sb.ToString()) as HttpWebRequest;
	request.Method = ″POST″;
	// Send the POST request
	var response = request.GetResponse();
	// Read the contents of the response
	OrderConfirmation orderConfirmation = null;
	using (var sr = new StreamReader(response.GetResponseStream()))
	{
		var str = sr.ReadToEnd();
		// Create an OrderConfirmation object from the response
		orderConfirmation = new OrderConfirmation(str);
	}
	return orderConfirmation;
}
{% endhighlight %}

使用URI隧道技术的服务在Richardson成熟度模型中被划分为一级服务。这类服务中URI是一个关键的概念，但是却不授受任何其他的WEB技术。HTTP也只被用作在WEB中移动URI的传输协议。

* POX：基于HTTP之上的普通老式XML

URI隧道技术使用地址来传递业务意图，第二种基于WEB的轻量级集成方法使用消息进行传递，如普通老式XML（Plain Old XML）, POX。

用XML和HTTP进行远程过程调用：

![用XML和HTTP进行远程过程调用][POXInteraction]

[POXInteraction]: /images/blog/REST/POXInteraction.png

1. POX调用始于客户系统中的一个对象调用一个分发器，该分发器为远程Restbucks服务展现一个本地接口。
2. 分发器将它从应用级对象所接受到的值转换成一个XML文档，然后调用一个HTTP客户端库来将信息传递到网络上。
3. HTTP客户端将分发器的XML载荷POST到远程服务。
4. 包含订购服务的WEB服务器接受进来的POST请求，并将请求的内容传给服务器端 的分发器。
5. 服务器端的分发器将XML文档翻译成Restbucks服务中的某个对象上的一个本地方法调用。
6. 当这个方法调用返回时，任何返回值都会被传给分发器。
7. 分发器使用返回值创建一个XML文档，并将它传回WEB服务器。
8. Web服务器产生一个HTTP响应（习惯上使用一个200状态代码），用来自分发器的XML文档作为消息体，使用与用于初始请求相同的HTTP连接来发送响应。
9. 消费者系统中的HTTP客户端收到响应，并且使客户端的分发器可以访问XML载荷。
10. 客户端的分发器从XML响应中提取值作为返回值，将它返回给初始调用对象，完成远程调用。

* XML-RPC

XML-RPC的前提是用XML作为通用的中间格式，在各种不同的系统中支持简单的远程过程调用。因此，XML-RPC被归入POX，因为它是使用HTTP POST和XML进行远程调用的。XML-RPC尝试对在HTTP请求和响应的载荷中表示这类信息的方法进行标准化，使不同的应用都不必发明自己的格式和实现到类型系统的映射。

POX服务在Richardson的成熟度模型中排在零级。零级服务使用HTTP作为传输协议，并使用单个URI作为对外公布的用来交换XML消息的端点。

### CRUD式Web服务

将Order建模为资源

1. 在顾客购买时创建订单
2. 订单会被频繁地读取，特别是在询问其准备状态时
3. 在某些情况下，还可以更新订单（例如，当顾客改变主意，或者要在饮料中添加特殊风味的时候）
4. 最后，如果某笔订单仍然处于待处理状态，允许顾客取消（或删除）订单

一笔订单的各种可能的状态：

![一笔订单的各种可能的状态][OrderState]

[OrderState]: /images/blog/REST/OrderState.png

CRUD订购服务的高级架构（用POST创建订单，用GET获取订单，用PUT更新订单，用DELETE删除订单）：

![CRUD订购服务的高级架构：][OrderingServiceArch]

[OrderingServiceArch]: /images/blog/REST/OrderingServiceArch.png

由于CRUD同时使用了HTTP和URI，它们被认为是处于Richardson成熟度模型的第二级。

* 建造CRUD式服务

订购服务中的契约概览：

| 动词 | URI或模板 | 用途 |
| ------ | ------ | ------ |
| POST | /order | 创建一个新订单，成功之后收到一个Location头信息，说明新订单的URI |
| GET | /order/{orderId} | 请求该URI所对应的订单的当前状态 |
| PUT | /order/{orderId} | 更新该URI所对应的订单，提供完整的表述 |
| DELETE | /order/{orderId} | 从逻辑上删除该URI所对应的订单 |

* 通过POST请求创建一笔咖啡订单

{% highlight xml %}

POST /order HTTP/1.1
Host: restbucks.com
Content-Type: application/xml
Content-Length: 239

<order xmlns=″http://schemas.restbucks.com/order″>
	<location>takeAway</location>
	<items>
		<item>
			<name>latte</name>
			<quantity>1</quantity>
			<milk>whole</milk>
			<size>small</size>
		</item>
	</items>
</order>

{% endhighlight %}

* 订单创建成功后的响应

{% highlight xml %}

HTTP/1.1 201 Created
Content-Length: 267
Content-Type: application/xml
Date: Wed, 19 Nov 2008 21:45:03 GMT
Location: http://restbucks.com/order/1234

<order xmlns=″http://schemas.restbucks.com/order″>
	<location>takeAway</location>
	<items>
		<item>
			<name>latte</name>
			<quantity>1</quantity>
			<milk>whole</milk>
			<size>small</size>
		</item>
	</items>
	<status>pending</status>
</order>

{% endhighlight %}

如果POST请求成功了，服务器会创建一个订单资源。随后，它用201 Created状态代码生成一个HTTP响应，用一个Location头信息包含新建订单的URI，并在响应消息体中包含对新订单状态的确认。

* 通过GET请求订单

{% highlight xml %}

GET /order/1234 HTTP/1.1
Host: restbucks.com

{% endhighlight %}

* 用GET读取订单

{% highlight xml %}

HTTP/1.1 200 OK
Content-Length: 241
Content-Type: application/xml
Date: Wed, 19 Nov 2008 21:48:10 GMT

<order xmlns=″http://schemas.restbucks.com/order″>
	<location>takeAway</location>
	<items>
		<item>
			<name>latte</name>
			<quantity>1</quantity>
			<milk>whole</milk>
			<size>small</size>
		</item>
	</items>
</order>

{% endhighlight %}

* 更新订单

{% highlight xml %}

PUT /order/1234 HTTP/1.1
Host: restbucks.com
Content-Type: application/xml
Content-Length: 246

<order xmlns=″http://schemas.restbucks.com/order″>
	<location>takeAway</location>
	<items>
		<item>
			<milk>skim</milk>
			<name>cappuccino</name>
			<quantity>1</quantity>
			<size>large</size>
		</item>
	</items>
</order>

{% endhighlight %}

PUT请求期望能将整个资源表述都提供给服务器，而不是只提供资源状态的变化量。另一个相对不太常用的HTTP动词，PATCH，建议在某些情况下使用（如涉及到大量的资源表述），通常只提供变化量。

当服务器接受并处理PUT请求时，消费者就会收到一个200 OK响应，或者204 No Centent响应。

如果使用PUT请求发送对资源的更新，但是服务并不支持此次更新，我们可以合理地预测，此时使用405 Method Not Allowed或者409 Conflict作为响应代码都是不错的选择。

* 用DELETE删除资源

{% highlight xml %}

DELETE /order/1234 HTTP/1.1
Host: restbucks.com

{% endhighlight %}

客户端指定了一个服务器无法映射到订单的URI，导致订购服务产生了一个404 Not Found响应。

* 安全性和幂等性

GET：既安全又幂等

PUT和DELETE：幂等，但不安全

POST：既不安全也不幂等

* 校正资源状态

在分布式应用中，经常会出现多个消费者与同一个资源交互的情况，每一位消费者都不理会其他人所做修改。除了这些由消费者驱动的变化，内部的服务行为也会导致资源状态发生消费者所不知道的变化。

HTTP提供了一种简单但强大的机制，可以按照实体标签(entity tag)与条件请求头信息(conditional request header)的形式，对所期待的资源状态进行校正（并防止产生竞争）。

包含ETAG的更新请求：

{% highlight xml %}

PUT /order/1234 HTTP/1.1
Host: restbucks.com
If-Match: ″72232bd0daafa12f7e2d1561c81cd082″

<order xmlns=″http://schemas.restbucks.com/order″>
	<location>takeAway</location>
	<items>
		<item>
			<milk>whole</milk>
			<name>cappuccino</name>
			<quantity>1</quantity>
			<size>large</size>
		</item>
	</items>
	<status>pending</preparing>
</order>

{% endhighlight %}

ETAG条件失败：

{% highlight xml %}

HTTP/1.1 412 Precondition Failed

{% endhighlight %}

### 超媒体服务

* 将超媒体作为应用状态的引擎

“将超媒体作为应用状态的引擎（Hypermedia As The Engine Of Application State）”一词，有时会缩写为“HATEOAS”，用来描述REST架构风格的核心原则。简单地说，这个原则说的是：超媒体转换了应用的状态。

资源的当前状态由以下几项共同组成：

1. 属于该资源的信息项（information item）的值
2. 相关资源的链接
3. 表示迁移到当前资源的未来某种可能状态的链接
4. 对于将该资源与其他本地资源相关联的任何业务规则的求值结果

服务通过对与有关资源的合法交互进行广告，强制实施了一个协议——领域应用协议(domain application protocol, 或称DAP)。当消费者跟随内嵌在资源表述中的链接与被链接的资源交互时，应用的整体状态发生了变化。

资源和超媒体共同描述了协议：

![资源和超媒体共同描述了协议：][Protocols]

[Protocols]: /images/blog/REST/Protocols.png

DAP指定了消费者与业务流程中所涉及的一组资源之间的合法交互。DAP居于HTTP之上，具体化了HTTP的广义应用协议，以便支持特定的业务目标。如我们所见，服务实现DAP是通过给资源表述添加超媒体链接来完成的。这些链接提示消费者可以与其他哪些资源进行交互，以便推进业务事务的前进。

* 松耦合

WEB契约是通过媒体类型和链接关系来表达的。授受一种媒体类型意味着当你与服务交互时，知道如何处理这种格式。使用服务所支持的媒体类型和链接关系时，通过对有效的新链接和状态迁移进行广告，我们可以在运行时扩展在WEB上的契约。

* 超媒体格式

标准的超媒体格式如Atom和XHTML已经得到广泛的使用与理解。相应地，有很多软件工具和库可以用来生产、消费和管理这些格式中的资源表述。不过，仅仅有广泛使用的工具做支持并不能使某种格式适合于各种领域。由于Web会中立于表述格式，因此我们可以放心地根据自己的问题领域创建自定义格式。

创建特定于领域的超媒体格式并不像想象中那么困难，只需在表述中引入一些额外的元素即可。

带有定制超媒体链接的咖啡订单：

{% highlight xml %}

<order xmlns=″http://schemas.restbucks.com″>
	<location>takeAway</location>
	<item>
		<name>latte</name>
		<quantity>1</quantity>
		<milk>whole</milk>
		<size>small</size>
	</item>
	<cost>2.0</cost>
	<status>payment-expected</status>
	<payment>https://restbucks.com/payment/1234</payment>
</order>

{% endhighlight %}

在这个格式中，订单表述中包含一个私有的<payment>元素。<payment>是一个超媒体控件。

最好的方法是将关注点分离，区分开链接的动作和给链接添加含义的动作。

{% highlight xml %}

<order xmlns=″http://schemas.restbucks.com″>
	<location>takeAway</location>
	<item>
		<name>latte</name>
		<quantity>1</quantity>
		<milk>whole</milk>
		<size>small</size>
	</item>
	<cost>2.0</cost>
	<status>payment-expected</status>
	<link rel=″http://relations.restbucks.com/payment″
	href=″https://restbucks.com/payment/1234″ />
</order>

{% endhighlight %}

* 处理超媒体格式

HTTP提供了一种办法，即使用Content-Type头信息来标识特殊媒体类型表述，例如：Content-Type:application/xml。

媒体类型是DAP的三大组件之一。另外两个组件是链接关系值和HTTP惯用语，前者用来描述被链接资源的作用，后者用来操作参与协议的资源。

* Restbucks的媒体类型

Content-Type头信息中用来与Restbucks交互的媒体类型表明是application/vnd.restbucks+xml。

虽然依旧选择以XML作为Restbucks的表述格式，但并不表示应该用text/xml或者application/xml作为Content-Type头信息的值，不这样做是有充分理由的。ContentType头信息设定了应该如何处理载荷的上下文。提示载荷仅仅是XML，这种做法在表述的内容和处理模型方面给出了软件代理错误的指示。将Restbucks内容及其超媒体控件格式视同普通的XML，只会使超媒体的路越走越窄。

在媒体类型和表述格式之间创建一种一一对应的映射关系，使用像application/vnd.restbucks.order+xml和application/vnd.restbucks.payment.reditCard+xml这类专用的媒体类型值，也会造成服务的领域层与其消费者之间产生紧密的耦合。

* 用超媒体对协议进行广告

为了实现超媒体服务，我们将在http://restbucks.com/order为订购服务创建一个入口点。为了启动订购协议，消费者用一个订单表述将一个POST请求发送到http://restbucks.com/order，结果就是创建一笔新的订单。POST请求的载荷必须是Restbucks订单的XML表述，并且Content-Type标题必须包含值application/vnd.restbucks+xml。

Restbucks订购协议驱动通道：

![Restbucks订购协议驱动通道][DrivingProtocol]

[DrivingProtocol]: /images/blog/REST/DrivingProtocol.png

响应包含了到达交互中后续有效步骤的链接：

![响应包含了到达交互中后续有效步骤的链接][ResponseInteraction]

[ResponseInteraction]: /images/blog/REST/ResponseInteraction.png

根据媒体类型的描述，Restbucks使用可重用的<link>元素来传达业务协议信息。我们将<link>元素及其属性与其他的Restbucks表述格式分离开，并在它自己的命名空间http://schemas.restbucks.com/dap中定义它：

1. <link>元素有一个uri属性，它的值表明了消费者要推进应用协议时可以与之交互的资源。
2. <link>元素有一个包含语义标记的rel属性，从标记值的定义可以推导出跟随链接时要使用的HTTP动词，以及需要的HTTP头信息和载荷的结构。
3. 如果请求需要一个实体信息体，<link>元素将包含一个声明了请求载荷格式的mediaType属性。如果请求不需要实体消息体，就没有mediaType属性。

超媒体订单表述：

{% highlight xml %}

<order xmlns=″http://schemas.restbucks.com″
xmlns:dap=″http://schemas.restbucks.com/dap″>
	<dap:link mediaType=″application/vnd.restbucks+xml″
	uri=″http://restbucks.com/order/1234″
	rel=″http://relations.restbucks.com/cancel″/>
	<dap:link mediaType=″application/vnd.restbucks+xml″
	uri=″http://restbucks.com/payment/1234″
	rel=″http://relations.restbucks.com/payment″/>
	<dap:link mediaType=″application/vnd.restbucks+xml″
	uri=″http://restbucks.com/order/1234″
	rel=″http://relations.restbucks.com/update″/>
	<dap:link mediaType=″application/vnd.restbucks+xml″
	uri=″http://restbucks.com/order/1234″ rel=″self″/>
	<item>
		<milk>semi</milk>
		<size>large</size>
		<drink>cappuccino</drink>
	</item>
	<location>takeAway</location>
	<cost>2.0</cost>
	<status>unpaid</status>
</order>

{% endhighlight %}

这个订单表述展示了与消费者可以用来推进DAP的不同URI和相关的rel值。语义标记的定义作为媒体类型规范的一部分与消费者广泛共享，这些值及含义如下：

payment: 被链接资源允许消费者开始支付订单。启动支付包括将一个适当的资源表述通过PUT请求发送到指定的URI，就像在Restbucks媒体类型中定义的那样。

self: uri值可以用于通过GET请求获取订单的最新资源表述。

update：消费者可以通过使用POST请求将表述传送给被链接资源来修改订单。

cancel: 当消费者希望取消订单时，这是用来发送DELETE请求的订单资源的URI。























