---
layout: post
title: Git从入门到精通（二）
date: 2018-09-18
comments: true 
tags: 学习笔记 工程管理 Git
summary: 本章内容涵盖你在使用 Git 完成各种工作中将要使用的各种基本命令。 在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。 本章也将向你演示如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。
---


### 获取Git仓库

* **在现有目录中初始化仓库**

如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：
	
	$ git init
	
* **在现有目录中初始化仓库**

如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。

	$ git clone https://github.com/libgit2/libgit2
	
如果你想在克隆远程仓库的时候，自定义本地仓库的名字

	$ git clone https://github.com/libgit2/libgit2 mylibgit
	
### 记录每次更新到仓库

你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。

文件的状态变化周期如下：

![文件的状态变化周期][lifecycle]

* **检查当前文件状态**

要查看哪些文件处于什么状态，可以用 git status 命令。

	$ git status
	On branch master
	nothing to commit, working directory clean
	
* **跟踪新文件**

使用命令 git add 开始跟踪一个文件。

	$ git add README
	
* **暂存已修改文件**

如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容：

	$ git status
	On branch master
	Changes to be committed:
	  (use "git reset HEAD <file>..." to unstage)

		new file:   README

	Changes not staged for commit:
	  (use "git add <file>..." to update what will be committed)
	  (use "git checkout -- <file>..." to discard changes in working directory)

		modified:   CONTRIBUTING.md

文件 CONTRIBUTING.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行git add命令。这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 

我们运行 git add 将"CONTRIBUTING.md"放到暂存区，然后再看看 git status 的输出：

	$ git add CONTRIBUTING.md
	$ git status
	On branch master
	Changes to be committed:
	  (use "git reset HEAD <file>..." to unstage)

		new file:   README
		modified:   CONTRIBUTING.md
		
现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 CONTRIBUTING.md 里再加条注释， 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看：

	$ vim CONTRIBUTING.md
	$ git status
	On branch master
	Changes to be committed:
	  (use "git reset HEAD <file>..." to unstage)

		new file:   README
		modified:   CONTRIBUTING.md

	Changes not staged for commit:
	  (use "git add <file>..." to update what will be committed)
	  (use "git checkout -- <file>..." to discard changes in working directory)

		modified:   CONTRIBUTING.md

怎么回事？ 现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 git add 命令时的版本， 如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。 所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：

	$ git add CONTRIBUTING.md
	$ git status
	On branch master
	Changes to be committed:
	  (use "git reset HEAD <file>..." to unstage)

		new file:   README
		modified:   CONTRIBUTING.md
		
* **状态简览**

如果你使用 git status -s 命令或 git status --short 命令，你将得到一种更为紧凑的格式输出。运行 git status -s ，状态报告输出如下：

	$ git status -s
	 M README
	MM Rakefile
	A  lib/git.rb
	M  lib/simplegit.rb
	?? LICENSE.txt

符号解释如下：

* ？？：未跟踪文件
* A：新添加到暂存区中的文件
* M：修改过的文件（出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。MM表示修改提交后又修改了）

* **忽略文件**

我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。

	$ cat .gitignore
	*.[oa]
	*~
	
第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件。

文件 .gitignore 的格式规范如下：

* 所有空行或者以 ＃ 开头的行都会被 Git 忽略。
* 可以使用标准的 glob 模式匹配。
* 匹配模式可以以（/）开头防止递归。
* 匹配模式可以以（/）结尾指定目录。
* 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。

所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（*) 表示匹配任意中间目录，比如`a/**/z` 可以匹配 a/z, a/b/z 或 `a/b/c/z`等。

例子：

	# no .a files
	*.a

	# but do track lib.a, even though you're ignoring .a files above
	!lib.a

	# only ignore the TODO file in the current directory, not subdir/TODO
	/TODO

	# ignore all files in the build/ directory
	build/

	# ignore doc/notes.txt, but not doc/server/arch.txt
	doc/*.txt

	# ignore all .pdf files in the doc/ directory
	doc/**/*.pdf

* **查看已暂存和未暂存的修改**

git diff 将通过文件补丁的格式显示具体哪些行发生了改变, 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。

要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff：

	$ git diff
	diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
	index 8ebb991..643e24f 100644
	--- a/CONTRIBUTING.md
	+++ b/CONTRIBUTING.md
	@@ -65,7 +65,8 @@ branch directly, things can get messy.
	 Please include a nice description of your changes when you submit your PR;
	 if we have to read the whole diff to figure out why you're contributing
	 in the first place, you're less likely to get feedback and have your change
	-merged in.
	+merged in. Also, split your changes into comprehensive chunks if your patch is
	+longer than a dozen lines.

	 If you are starting to work on a particular area, feel free to submit a PR
	 that highlights your work in progress (and note in the PR title that it's
 
若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令。（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的，但更好记些。）

	$ git diff --staged
	diff --git a/README b/README
	new file mode 100644
	index 0000000..03902a1
	--- /dev/null
	+++ b/README
	@@ -0,0 +1 @@
	+My Project
	
Note:

	Git Diff 的插件版本
	
	在本书中，我们使用 git diff 来分析文件差异。 但是，如果你喜欢通过图形化的方式或其它格式输出方式的话，可以使用 git difftool 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。 使用 git difftool --tool-help 命令来看你的系统支持哪些 Git Diff 插件。

* **提交更新**

每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit：

这种方式会启动文本编辑器以便输入本次提交的说明。 (默认会启用 shell 的环境变量 $EDITOR 所指定的软件，一般都是 vim 或 emacs。当然也可以按照 起步 介绍的方式，使用 git config --global core.editor 命令设定你喜欢的编辑软件。）

编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：

	# Please enter the commit message for your changes. Lines starting
	# with '#' will be ignored, and an empty message aborts the commit.
	# On branch master
	# Changes to be committed:
	#	new file:   README
	#	modified:   CONTRIBUTING.md
	#
	~
	~
	~
	".git/COMMIT_EDITMSG" 9L, 283C
	
[lifecycle]: /images/blog/ProGit/2/lifecycle.jpg

