---
layout: post
title: Git从入门到精通（三）
date: 2018-09-23
comments: true 
tags: 学习笔记 工程管理 Git
summary: 有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。
---


### 分支简介

我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会
为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到
Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：

	$ git add README test.rb LICENSE
	$ git commit -m 'The initial commit of my project'

当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在
Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，
还包含指向这个树对象（项目根目录）的指针。

现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象
索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。

首次提交对象及其树结构： 

![首次提交对象及其树结构][commit-and-tree]

做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。

提交对象及其父对象：

![提交对象及其父对象][commits-and-parents]

Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。

>注意：Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。

分支及其提交历史：

![分支及其提交历史][branch-and-history]


* **分支创建**

创建一个 testing 分支， 你需要使用 git branch 命令：

	$ git branch testing
	
这会在当前所在的提交对象上创建一个指针。

两个指向相同提交历史的分支：

![两个指向相同提交历史的分支][two-branches]

那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。

HEAD 指向当前所在的分支：

![HEAD 指向当前所在的分支][head-to-master]

你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。

	$ git log --oneline --decorate
	f30ab (HEAD, master, testing) add feature #32 - ability to add new
	34ac2 fixed bug #1328 - stack overflow under certain conditions
	98ca9 initial commit of my project

* **分支切换**

要切换到一个已存在的分支，你需要使用 git checkout 命令。

	$ git checkout testing

HEAD 指向当前所在的分支：

![HEAD 指向当前所在的分支][head-to-testing]

HEAD 分支随着提交操作自动向前移动：

![HEAD 分支随着提交操作自动向前移动][advance-testing]

现在我们切换回 master 分支看看。

	$ git checkout master
	
检出时 HEAD 随之移动：

![检出时 HEAD 随之移动][checkout-master]

这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 

>注意：分支切换会改变你工作目录中的文件在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。

稍微做些修改并提交：

	$ vim test.rb
	$ git commit -a -m 'made other changes'	
	
现在，这个项目的提交历史已经产生了分叉。

项目分叉历史：

![项目分叉历史][advance-master]

你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。

	$ git log --oneline --decorate --graph --all
	* c2b9e (HEAD, master) made other changes
	| * 87ab2 (testing) made a change
	|/
	* f30ab add feature #32 - ability to add new formats to the
	* 34ac2 fixed bug #1328 - stack overflow under certain conditions
	* 98ca9 initial commit of my project
	
由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 

### 分支的新建与合并

让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：

1. 开发某个网站。
2. 为实现某个新的需求，创建一个分支。
3. 在这个分支上开展工作。

正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：

1. 切换到你的线上分支（production branch）。
2. 为这个紧急任务新建一个分支，并在其中修复它。
3. 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。
4. 切换回你最初工作的分支上，继续工作。

* **新建分支

首先，我们假设你正在你的项目上工作，并且已经有一些提交

一个简单提交历史：

![一个简单提交历史][basic-branching-1]

现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令：

	$ git checkout -b iss53
	Switched to a new branch "iss53"

它是下面两条命令的简写：

	$ git branch iss53
	$ git checkout iss53
	
创建一个新分支指针：

![创建一个新分支指针][basic-branching-2]
	
你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，iss53 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 HEAD 指针指向了 iss53 分支）

分支随着工作的进展向前推进：

![分支随着工作的进展向前推进][basic-branching-3]

现在你接到那个电话，有个紧急问题等待你来解决。 你所要做的仅仅是切换回 master 分支。但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了：

	$ git checkout master
	Switched to branch 'master'
	
让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：

	$ git checkout -b hotfix
	Switched to a new branch 'hotfix'
	$ vim index.html
	$ git commit -a -m 'fixed the broken email address'
	[hotfix 1fb7853] fixed the broken email address
	 1 file changed, 2 insertions(+)
	
基于 master 分支的紧急问题分支 hotfix branch

![基于 master 分支的紧急问题分支 hotfix branch][basic-branching-4]

你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 master 分支来部署到线上。 你可以使用 git merge 命令来达到上述目的：

	$ git checkout master
	$ git merge hotfix
	Updating f42c576..3a0874c
	Fast-forward
	 index.html | 2 ++
	 1 file changed, 2 insertions(+)

在合并的时候，你应该注意到了"快进（fast-forward）"这个词。 由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。

master 被快进到 hotfix：

![master 被快进到 hotfix][basic-branching-5]

关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix 分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支：

	$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).
	
现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。

	$ git checkout iss53
	Switched to branch "iss53"
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53 ad82d7a] finished the new footer [issue 53]
	1 file changed, 1 insertion(+)

继续在 iss53 分支上的工作：

![继续在 iss53 分支上的工作][basic-branching-6]

* **分支的合并**

你只需要检出到你想合并入的分支，然后运行 git merge 命令：

	$ git checkout master
	Switched to branch 'master'
	$ git merge iss53
	Merge made by the 'recursive' strategy.
	index.html |    1 +
	1 file changed, 1 insertion(+)

这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。

一次典型合并中所用到的三个快照：

![一次典型合并中所用到的三个快照][basic-merging-1]

和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。

既然你的修改已经合并进来了，你已经不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。

	$ git branch -d iss53
	
* **遇到冲突时的分支合并**

如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：

$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：

	$ git status
	On branch master
	You have unmerged paths.
	  (fix conflicts and run "git commit")

	Unmerged paths:
	  (use "git add <file>..." to mark resolution)

		both modified:      index.html

	no changes added to commit (use "git add" and/or "git commit -a")

任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：

	<<<<<<< HEAD:index.html
	<div id="footer">contact : email.support@github.com</div>
	=======
	<div id="footer">
	 please contact us at support@github.com
	</div>
	>>>>>>> iss53:index.html

为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：

	<div id="footer">
	please contact us at email.support@github.com
	</div>

在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。

如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：

	$ git mergetool

	This message is displayed because 'merge.tool' is not configured.
	See 'git mergetool --tool-help' or 'git help config' for more details.
	'git mergetool' will now attempt to use one of the following tools:
	opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
	Merging:
	index.html

	Normal merge conflict for 'index.html':
	  {local}: modified file
	  {remote}: modified file
	Hit return to start merge resolution tool (opendiff):
	

>注意：如果你需要更加高级的工具来解决复杂的合并冲突，我们会在 高级合并 介绍更多关于分支合并的内容。

可以再次运行 git status 来确认所有的合并冲突都已被解决：
	
	$ git status
	On branch master
	All conflicts fixed but you are still merging.
	  (use "git commit" to conclude merge)

	Changes to be committed:

		modified:   index.html
	
### 分支管理

git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：

	$ git branch
	  iss53
	* master
	  testing
	  
注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：

	$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes
	  
--merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged：

	$ git branch --merged
	  iss53
	* master
	
查看所有包含未合并工作的分支，可以运行 git branch --no-merged：

	$ git branch --no-merged
	  testing
	  
这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败：

	$ git branch -d testing
	error: The branch 'testing' is not fully merged.
	If you are sure you want to delete it, run 'git branch -D testing'.

如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它。

### 分支开发工作流

* **长期分支**

在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 

渐进稳定分支的线性图：

![渐进稳定分支的线性图][lr-branches-1]

通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。

渐进稳定分支的流水线（“silo”）视图：

![渐进稳定分支的流水线（“silo”）视图][lr-branches-2]

* **特性分支**

考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：

拥有多个特性分支的提交历史：

![拥有多个特性分支的提交历史][topic-branches-1]

现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案；另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：

合并了 dumbidea 和 iss91v2 分支之后的提交历史：

![合并了 dumbidea 和 iss91v2 分支之后的提交历史][topic-branches-2]
		
请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。
	
### 远程分支

你可以通过 git ls-remote (remote) 来显式地获得远程引用的完整列表，或者通过 git remote show (remote) 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。
 
远程跟踪分支是远程分支状态的引用。它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。

假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。

>注意：“origin” 并无特殊含义。远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。
	
克隆之后的服务器与本地仓库:

![克隆之后的服务器与本地仓库][remote-branches-1]

如果你在本地的 master 分支做了一些工作，然而在同一时间，其他人推送提交到 git.ourcompany.com 并更新了它的 master 分支，那么你的提交历史将向不同的方向前进。 也许，只要你不与 origin 服务器连接，你的 origin/master 指针就不会移动。

本地与远程的工作可以分叉:

![本地与远程的工作可以分叉][remote-branches-2]
	
如果要同步你的工作，运行 git fetch origin 命令。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com），从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针指向新的、更新后的位置。

git fetch 更新你的远程仓库引用:

![git fetch 更新你的远程仓库引用][remote-branches-3]

我们假定你有另一个内部 Git 服务器，仅用于你的 sprint 小组的开发工作。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目。

添加另一个远程仓库:

![添加另一个远程仓库][remote-branches-4]

现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。

远程跟踪分支 teamone/master:

![远程跟踪分支 teamone/master][remote-branches-4]

* **推送**

如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push (remote) (branch):

	$ git push origin serverfix
	Counting objects: 24, done.
	Delta compression using up to 8 threads.
	Compressing objects: 100% (15/15), done.
	Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
	Total 24 (delta 2), reused 0 (delta 0)
	To https://github.com/schacon/simplegit
	 * [new branch]      serverfix -> serverfix

下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：

	$ git fetch origin
	remote: Counting objects: 7, done.
	remote: Compressing objects: 100% (2/2), done.
	remote: Total 3 (delta 0), reused 3 (delta 0)
	Unpacking objects: 100% (3/3), done.
	From https://github.com/schacon/simplegit
	 * [new branch]      serverfix    -> origin/serverfix	 

要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支 - 只有一个不可以修改的 origin/serverfix 指针。

可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：

	$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch serverfix from origin.
	Switched to a new branch 'serverfix'	 
	
* **跟踪分支**

从一个远程跟踪分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。

当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支 - 其他远程仓库上的跟踪分支，或者不跟踪 master 分支。 最简单的就是之前看到的例子，运行 git checkout -b [branch] [remotename]/[branch]。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：

	$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch serverfix from origin.
	Switched to a new branch 'serverfix'
	
如果想要将本地分支与远程分支设置为不同名字，你可以轻松地增加一个不同名字的本地分支的上一个命令：

	$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch serverfix from origin.
	Switched to a new branch 'sf'

设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。

	$ git branch -u origin/serverfix
	Branch serverfix set up to track remote branch serverfix from origin.	
	
如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。

	$ git branch -vv
	  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
	  master    1ae2a45 [origin/master] deploying index fix
	* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
	  testing   5ea463a trying something new
	  
这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1，意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。

需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：

	$ git fetch --all; git branch -vv

* **拉取**

当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。

* **删除远程分支**

如果想要从服务器上删除 serverfix 分支，运行下面的命令：

	$ git push origin --delete serverfix
	To https://github.com/schacon/simplegit
	 - [deleted]         serverfix

基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。

### 变基

将 C4 中的修改变基到 C3 上:

	$ git checkout experiment
	$ git rebase master
	First, rewinding head to replay your work on top of it...
	Applying: added staged command

![将 C4 中的修改变基到 C3 上][basic-rebase-3]

它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。

现在回到 master 分支，进行一次快进合并。

	$ git checkout master
	$ git merge experiment

master 分支的快进合并:

![master 分支的快进合并][basic-rebase-4]

一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。

* **更有趣的变基例子**

从一个特性分支里再分出一个特性分支的提交历史:

![从一个特性分支里再分出一个特性分支的提交历史][interesting-rebase-1]

假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改，因为它们还需要经过更全面的测试。 这时，你就可以使用 git rebase 命令的 --onto 选项，选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：

	$ git rebase --onto master server client
	
以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍”。 这理解起来有一点复杂，不过效果非常酷。

截取特性分支上的另一个特性分支，然后变基到其他分支:

![变基到其他分支][interesting-rebase-2]

现在可以快进合并 master 分支了。

	$ git checkout master
	$ git merge client
	
快进合并 master 分支，使之包含来自 client 分支的修改:

![快进合并 master 分支][interesting-rebase-3]

接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase [basebranch] [topicbranch] 命令可以直接将特性分支（即本例中的 server）变基到目标分支（即 master）上。这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。

	$ git rebase master server
	
将 server 中的修改变基到 master 上:
	
![将 server 中的修改变基到 master 上][interesting-rebase-4]	

然后就可以快进合并主分支 master 了：

	$ git checkout master
	$ git merge server

至此，client 和 server 分支中的修改都已经整合到主分支里了，你可以删除这两个分支，最终提交历史会变成图中的样子：

	$ git branch -d client
	$ git branch -d server
	
最终的提交历史:
	
![最终的提交历史][interesting-rebase-5]	


	
[commit-and-tree]: /images/blog/ProGit/3/commit-and-tree.png
[commits-and-parents]: /images/blog/ProGit/3/commits-and-parents.png
[branch-and-history]: /images/blog/ProGit/3/branch-and-history.png
[two-branches]: /images/blog/ProGit/3/two-branches.png
[head-to-master]: /images/blog/ProGit/3/head-to-master.png
[head-to-testing]: /images/blog/ProGit/3/head-to-testing.png
[advance-testing]: /images/blog/ProGit/3/advance-testing.png
[checkout-master]: /images/blog/ProGit/3/checkout-master.png
[advance-master]: /images/blog/ProGit/3/advance-master.png
[basic-branching-1]: /images/blog/ProGit/3/basic-branching-1.png
[basic-branching-2]: /images/blog/ProGit/3/basic-branching-2.png
[basic-branching-3]: /images/blog/ProGit/3/basic-branching-3.png
[basic-branching-4]: /images/blog/ProGit/3/basic-branching-4.png
[basic-branching-5]: /images/blog/ProGit/3/basic-branching-5.png
[basic-branching-6]: /images/blog/ProGit/3/basic-branching-6.png
[basic-merging-1]: /images/blog/ProGit/3/basic-merging-1.png
[lr-branches-1]: /images/blog/ProGit/3/lr-branches-1.png
[lr-branches-2]: /images/blog/ProGit/3/lr-branches-2.png
[topic-branches-1]: /images/blog/ProGit/3/topic-branches-1.png
[topic-branches-2]: /images/blog/ProGit/3/topic-branches-2.png
[remote-branches-1]: /images/blog/ProGit/3/remote-branches-1.png
[remote-branches-2]: /images/blog/ProGit/3/remote-branches-2.png
[remote-branches-3]: /images/blog/ProGit/3/remote-branches-3.png
[remote-branches-4]: /images/blog/ProGit/3/remote-branches-4.png
[basic-rebase-3]: /images/blog/ProGit/3/basic-rebase-3.png
[basic-rebase-4]: /images/blog/ProGit/3/basic-rebase-4.png
[interesting-rebase-1]: /images/blog/ProGit/3/interesting-rebase-1.png
[interesting-rebase-2]: /images/blog/ProGit/3/interesting-rebase-2.png
[interesting-rebase-3]: /images/blog/ProGit/3/interesting-rebase-3.png
[interesting-rebase-4]: /images/blog/ProGit/3/interesting-rebase-4.png
[interesting-rebase-5]: /images/blog/ProGit/3/interesting-rebase-5.png


