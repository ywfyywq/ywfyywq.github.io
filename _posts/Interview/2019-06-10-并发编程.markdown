---
layout: post
title: 并发编程
date: 2019-06-10
comments: true 
tags: 面试
summary: 
Java并发编程必懂知识点解析及常见面试问题解答。
---
## 基本概念

### 并发编程三要素

* **原子性**

原子，即一个不可再被分割的颗粒。在Java中原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。

* **有序性**

程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）

* **可见性**

当多个线程访问同一个变量时，如果其中一个线程对其作了修改，其他线程能立即获取到最新的值。



### 线程状态

* **创建(NEW)**

当用 new 操作符创建一个线程的时候

* **就绪(RUNNABLE)**

调用 start 方法，处于就绪状态的线程并不一定马上就会执行 run 方法，还需要等待CPU的调度

* **运行(RUNNING)**

CPU 开始调度线程，并开始执行 run 方法

* **阻塞(BLOCKED)**

阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。

阻塞的情况分三种： 

(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

* **死亡(DEAD)**

线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。



### 悲观锁和乐观锁

* **悲观锁**

每次操作都会加锁，会造成线程阻塞。

* **乐观锁**

每次操作不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，不会造成线程阻塞。



### volatile关键字

* 概要

java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。

volatile是轻量级的synchronized，不会引起线程上下文的切换和调度，执行开销更小。

* 原理

1. 使用volatile修饰的变量在汇编阶段，会多出一条lock前缀指令

2. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成

3. 它会强制将对缓存的修改操作立即写入主存

4. 如果是写操作，它会导致其他CPU里缓存了该内存地址的数据无效

* 作用

1. 内存可见性: 多线程操作的时候，一个线程修改了一个变量的值 ，其他线程能立即看到修改后的
2. 防止重排序: 即程序的执行顺序按照代码的顺序执行（处理器为了提高代码的执行效率可能会对代码进行重排序）



### synchronized关键字

* 概要

synchronized 是JVM实现的一种锁，其中锁的获取和释放分别是monitorenter 和 monitorexit 指令。

* 原理

加了 synchronized 关键字的代码段，生成的字节码文件会多出 monitorenter 和 monitorexit 两条指令（利用javap -verbose 字节码文件可看到）

* 缺点

会让没有得到锁的资源进入Block状态，争夺到资源之后又转为Running状态，这个过程涉及到操作系统用户模式和内核模式的切换，代价比较高。Java1.6为 synchronized 做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。



### CAS

* 定义

CAS全称是Compare And Swap，即比较替换，是实现并发应用到的一种技术。操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。

* 比较

如果只是用 synchronized 来保证同步会存在以下问题：

synchronized 是一种悲观锁，在使用上会造成一定的性能问题。在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。一个线程持有锁会导致其它所有需要此锁的线程挂起。

* 原理

Java不能直接的访问操作系统底层，是通过native方法（JNI）来访问。CAS底层通过Unsafe类实现原子性操作。

* 存在问题

ABA问题。比如有一个 int 类型的值 N 是 1

此时有三个线程想要去改变它：

线程A ：预期值为1，新值为2

线程B： 预期值为1，新值为2

线程C： 预期值为2，新值为1

此时线程A和线程B同时获取到N的值1，线程A率先得到系统资源，将 N 赋值为 2，线程 B 由于某种原因被阻塞住，线程C在线程A执行完后得到 N 的当前值2

此时的线程状态：

线程A成功给 N 赋值为2

线程B获取到 N 的当前值 1 希望给他赋值为 2，处于阻塞状态

线程C获取当好 N 的当前值 2 希望给他赋值为1

然后线程C成功给N赋值为1

最后线程B得到了系统资源，又重新恢复了运行状态，在阻塞之前线程B获取到的N的值是1，执行compare操作发现当前N的值与获取到的值相同（均为1），成功将N赋值为了2。

在这个过程中线程B获取到N的值是一个旧值，虽然和当前N的值相等，但是实际上N的值已经经历了一次 1到2到1的改变。

* 问题解决

给变量加一个版本号即可，在比较的时候不仅要比较当前变量的值 还需要比较当前变量的版本号。Java中AtomicStampedReference 就解决了这个问题。

在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。



### AbstractQueuedSynchronizer(AQS)

AQS抽象的队列式同步器，是一种基于状态（state）的链表管理方式。state 是用CAS去修改的。它是 java.util.concurrent 包中最重要的基石。



### **线程池**

如果我们使用线程的时候就去创建一个线程，虽然简单，但是存在很大的问题。如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。线程池通过复用可以大大减少线程频繁创建与销毁带来的性能上的损耗。



## 面试题

### 在java中守护线程和本地线程区别

java中的线程分为两种：守护线程（Daemon）和用户线程（User）。

任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。

两者的区别： 
		唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。



### 线程与进程的区别

进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。

一个程序至少有一个进程,一个进程至少有一个线程。



### 什么是多线程中的上下文切换

多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。



### 死锁与活锁的区别，死锁与饥饿的区别

**死锁**：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

产生死锁的必要条件： 
1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。 
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
3. 不剥夺条件:进程已获得资源，在未使用完之前，不能强行剥夺。 
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**活锁**：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

**饥饿**：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。

Java中导致饥饿的原因： 
- 高优先级线程吞噬所有的低优先级线程的CPU时间。 
- 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。 
- 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。



### 在Java中Executor和Executors的区别

Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。 
Executor 接口对象能执行我们的线程任务。 

ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。 

使用ThreadPoolExecutor 可以创建自定义线程池。 

Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。



### Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？

Lock接口比同步方法和同步块提供了更具扩展性的锁操作。 
他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。

它的优势有：

可以使锁更公平

可以使线程在等待锁的时候响应中断

可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间

可以在不同的范围，以不同的顺序获取和释放锁

整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。



### 什么是Callable和Future?

Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。 
可以认为是带有回调的Runnable。

Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。



### 什么是并发容器的实现？

何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。 

可以通过查看Vector，Hashtable等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。

并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。



### 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。 

但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。



### 在Java中CycliBarriar和CountdownLatch有什么区别？

CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。 
Java的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。 
你可以向CountDownLatch对象设置一个初始的数字作为计数值，任何调用这个对象上的await()方法都会阻塞，直到这个计数器的计数值被其他的线程减为0为止。 

所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 
CountDownLatch的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。

CyclicBarrier一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。



### SynchronizedMap和ConcurrentHashMap有什么区别？

SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。

ConcurrentHashMap使用分段锁来保证在多线程下的性能。ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。 

另外ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。



### CopyOnWriteArrayList可以用于什么应用场景？

CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。

1、由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc； 

2、不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；

CopyOnWriteArrayList透露的思想 

1、读写分离，读和写分开

2、最终一致性 

3、使用另外开辟空间的思路，来解决并发冲突



### 为什么你应该在循环中检查等待条件?

处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。



### java中有几种方法可以实现一个线程？

1、继承Thread类创建线程

2、实现Runnable接口创建线程

3、实现Callable接口通过FutureTask包装器来创建Thread线程

4、使用ExecutorService、Callable、Future实现有返回结果的线程



### 如何停止一个正在运行的线程？

1. 使用退出标志
2. 使用 interrupt 方法
3. 使用 interrupt() + isInterrupted()



### sleep()和 wait()有什么区别?

对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。

sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。

在调用sleep()方法的过程中，线程不会释放对象锁。

而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

获取对象锁进入运行状态。



### 什么是可重入锁（ReentrantLock）？

是指当前线程加锁的对象，本线程可以再次访问。



### 当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？

当一个线程进入一个对象的synchronized()方法后，其他线程是否可以进入此对象的其他方法取决于方法本身，如果该方法是非synchronized()方法，那么是可以访问的，如果是synchronized()方法,那么不能访问。



### synchronized和java.util.concurrent.locks.Lock的异同？

1.Lock能完成几乎所有synchronized的功能，并有一些后者不具备的功能，如锁投票、定时锁等候、可中断锁等候等

   2.synchronized 是Java 语言层面的，是内置的关键字；Lock 则是JDK 5中出现的一个包，在使用时，synchronized 同步的代码块可以由JVM自动释放；Lock 需要程序员在finally块中手工释放，如果不释放，可能会引起难以预料的后果（在多线程环境中）。



### 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。



### SynchronizedMap和ConcurrentHashMap有什么区别？

SynchronizedMap

　　一次性锁住整张表来保证线程安全，所以每次只能有一个线程来访问map。

- synchronizedMap**实现了Map接口**。
- 构造synchronizedMap时将**this指针传递给监视器对象mutex**，即**同步方法块锁住的是synchronizedMap对象自身**，并**将方法代理在Map集合m的方法上**。
- synchronizedMap是Collections的**私有静态内部类**，可以**通过Collecitons.synchronizedMap(Map)方法获取一个synchronizedMap向上转型为Map对象**，对外发布。
- synchronizedMap**将一个非线程安全的Map集合通过同步方法块锁住对象自身包装为线程安全的Map集合**。

 

ConcurrentHashMap

　　使用分段锁来保证在多线程下的性能。一次锁住一个桶。默认将hash表分为16个桶， 诸如 get put remove等常见操作只锁当前需要用到的桶。

　　这样只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。



### CopyOnWriteArrayList可以用于什么应用场景？

读写分离，适合写少读多的场景。使用了独占锁，支持多线程下的并发写。

